<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Surviving The World‚Ñ¢ - AAA Medieval Survival</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;font-family:'Segoe UI',Arial,sans-serif;overflow:hidden;color:#fff}
#menu{position:fixed;inset:0;background:linear-gradient(135deg,#0a0a15 0%,#1a1a2e 50%,#0a0a15 100%);
display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:1000}
.logo{font-size:3.5em;color:#ffd700;text-shadow:0 0 40px rgba(255,215,0,0.6),0 4px 8px rgba(0,0,0,0.8);margin-bottom:10px;font-weight:bold}
.subtitle{color:#888;margin-bottom:40px;letter-spacing:3px;font-size:14px}
.chars{display:flex;gap:20px;flex-wrap:wrap;justify-content:center;max-width:900px}
.char{width:150px;padding:25px 15px;background:linear-gradient(180deg,#1a1a2e,#12121f);border:2px solid #333;border-radius:15px;cursor:pointer;text-align:center;transition:all .3s ease}
.char:hover{border-color:#ffd700;transform:translateY(-8px);box-shadow:0 15px 40px rgba(255,215,0,0.3)}
.char .icon{font-size:48px;margin-bottom:12px}
.char .name{font-weight:bold;font-size:16px;margin-bottom:8px;color:#fff}
.char .stats{color:#888;font-size:11px;line-height:1.4}
.hint{color:#555;margin-top:40px;font-size:12px}
#game{display:none;position:fixed;inset:0}
#gameCanvas{width:100%;height:100%;display:block}
#hud{position:fixed;top:20px;left:20px;z-index:100}
.stat{margin-bottom:10px;display:flex;align-items:center;gap:10px}
.stat-icon{font-size:18px;filter:drop-shadow(0 2px 4px rgba(0,0,0,0.5))}
.stat-bar{width:180px;height:20px;background:rgba(0,0,0,0.7);border-radius:10px;overflow:hidden;border:2px solid rgba(255,255,255,0.2);box-shadow:inset 0 2px 4px rgba(0,0,0,0.5)}
.stat-fill{height:100%;border-radius:8px;transition:width .3s;box-shadow:0 0 10px currentColor}
.hp-fill{background:linear-gradient(90deg,#8B0000,#dc3545,#ff6b6b);color:#ff6b6b}
.st-fill{background:linear-gradient(90deg,#0d5016,#28a745,#5dd879);color:#5dd879}
.hu-fill{background:linear-gradient(90deg,#8B4513,#fd7e14,#ffc107);color:#ffc107}
.stat-text{font-size:12px;color:#fff;min-width:60px;text-shadow:0 1px 2px rgba(0,0,0,0.8)}
#info{position:fixed;top:20px;right:20px;text-align:right;z-index:100;background:rgba(0,0,0,0.5);padding:15px;border-radius:10px;border:1px solid rgba(255,255,255,0.1)}
#day{font-size:22px;color:#ffd700;font-weight:bold;text-shadow:0 2px 4px rgba(0,0,0,0.5)}
#weather{font-size:14px;color:#ccc;margin-top:5px}
#heat{margin-top:12px;font-size:12px}
.heat-row{margin:6px 0;display:flex;align-items:center;justify-content:flex-end;gap:10px}
.heat-tag{padding:5px 14px;border-radius:15px;font-size:11px;font-weight:bold;text-transform:uppercase;letter-spacing:1px}
.calm{background:linear-gradient(135deg,#1a5f2a,#28a745);color:#fff;box-shadow:0 0 10px rgba(40,167,69,0.5)}
.alert{background:linear-gradient(135deg,#c77600,#fd7e14);color:#fff;box-shadow:0 0 10px rgba(253,126,20,0.5)}
.hunting{background:linear-gradient(135deg,#8B0000,#dc3545);color:#fff;box-shadow:0 0 10px rgba(220,53,69,0.5)}
#minimap{position:fixed;bottom:20px;right:20px;width:200px;height:200px;background:rgba(0,0,0,0.8);border:3px solid #ffd700;border-radius:50%;z-index:100;box-shadow:0 0 20px rgba(255,215,0,0.3)}
#log{position:fixed;bottom:20px;left:20px;width:350px;max-height:200px;background:rgba(0,0,0,0.8);border-radius:12px;padding:15px;z-index:100;overflow-y:auto;border:1px solid rgba(255,255,255,0.1)}
#log-title{color:#ffd700;margin-bottom:10px;font-weight:bold;font-size:14px;text-transform:uppercase;letter-spacing:1px}
.log-entry{padding:5px 0;border-bottom:1px solid rgba(255,255,255,0.1);color:#aaa;font-size:12px}
.log-combat{color:#ff6b6b}.log-quest{color:#ffd700}.log-ai{color:#5bc0de}.log-system{color:#5dd879}
#controls{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);padding:12px 30px;border-radius:30px;z-index:100;font-size:12px;color:#888;border:1px solid rgba(255,255,255,0.1)}
#crosshair{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:100;pointer-events:none}
#crosshair::before,#crosshair::after{content:'';position:absolute;background:rgba(255,255,255,0.8);box-shadow:0 0 5px rgba(255,255,255,0.5)}
#crosshair::before{width:2px;height:24px;left:11px;top:0}
#crosshair::after{width:24px;height:2px;top:11px;left:0}
</style>
</head>
<body>
<div id="menu">
<div class="logo">‚öîÔ∏è SURVIVING THE WORLD‚Ñ¢</div>
<div class="subtitle">NEXT-GEN MEDIEVAL SURVIVAL</div>
<div class="chars">
<div class="char" onclick="startGame(0)"><div class="icon">‚öîÔ∏è</div><div class="name">Warrior</div><div class="stats">HP: 150 | DMG: 25<br>Speed: 5 | Armor: High</div></div>
<div class="char" onclick="startGame(1)"><div class="icon">üèπ</div><div class="name">Ranger</div><div class="stats">HP: 100 | DMG: 20<br>Speed: 7 | Perception+</div></div>
<div class="char" onclick="startGame(2)"><div class="icon">üó°Ô∏è</div><div class="name">Assassin</div><div class="stats">HP: 80 | DMG: 35<br>Speed: 9 | Stealth+</div></div>
<div class="char" onclick="startGame(3)"><div class="icon">üõ°Ô∏è</div><div class="name">Tank</div><div class="stats">HP: 200 | DMG: 15<br>Speed: 4 | Armor: Max</div></div>
<div class="char" onclick="startGame(4)"><div class="icon">üßô</div><div class="name">Survivor</div><div class="stats">HP: 120 | DMG: 18<br>Speed: 5 | Hunger-</div></div>
</div>
<div class="hint">WASD = Move | Mouse = Look | SHIFT = Sprint | E = Interact | Q = Attack</div>
</div>
<div id="game">
<canvas id="gameCanvas"></canvas>
<div id="crosshair"></div>
<div id="hud">
<div class="stat"><span class="stat-icon">‚ù§Ô∏è</span><div class="stat-bar"><div class="stat-fill hp-fill" id="hp"></div></div><span class="stat-text" id="hp-text">150/150</span></div>
<div class="stat"><span class="stat-icon">‚ö°</span><div class="stat-bar"><div class="stat-fill st-fill" id="st"></div></div><span class="stat-text" id="st-text">100%</span></div>
<div class="stat"><span class="stat-icon">üçñ</span><div class="stat-bar"><div class="stat-fill hu-fill" id="hu"></div></div><span class="stat-text" id="hu-text">80%</span></div>
</div>
<div id="info">
<div id="day">Day 1 | 06:00</div>
<div id="weather">‚òÄÔ∏è Clear | 22¬∞C</div>
<div id="heat">
<div class="heat-row">Kingdom <span class="heat-tag calm" id="h-kingdom">CALM</span></div>
<div class="heat-row">Bandits <span class="heat-tag alert" id="h-bandits">ALERT</span></div>
</div>
</div>
<canvas id="minimap" width="200" height="200"></canvas>
<div id="log"><div id="log-title">üìú Adventure Log</div><div id="log-entries"></div></div>
<div id="controls">WASD Move | Mouse Look | SHIFT Sprint | E Interact | Q Attack</div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SURVIVING THE WORLD‚Ñ¢ - AAA NEXT-GEN ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

let scene, camera, renderer, composer, clock;
let player, playerYaw = 0, playerPitch = 0;
let keys = {}, enemies = [], npcs = [], items = [], buildings = [];
let hp = 100, maxHp = 100, stamina = 100, hunger = 80;
let day = 1, gameTime = 6;
let heat = { kingdom: 0, bandits: 25 };
let isLocked = false;
let sun, sunTarget;

const CHARS = [
  { name: 'Warrior', color: 0xe74c3c, hp: 150, spd: 5, dmg: 25, armor: 0.3 },
  { name: 'Ranger', color: 0x27ae60, hp: 100, spd: 7, dmg: 20, armor: 0.1 },
  { name: 'Assassin', color: 0x9b59b6, hp: 80, spd: 9, dmg: 35, armor: 0.05 },
  { name: 'Tank', color: 0x3498db, hp: 200, spd: 4, dmg: 15, armor: 0.5 },
  { name: 'Survivor', color: 0xf39c12, hp: 120, spd: 5, dmg: 18, armor: 0.2 }
];
let cfg;

window.startGame = function(i) {
  cfg = CHARS[i];
  hp = cfg.hp;
  maxHp = cfg.hp;
  document.getElementById('menu').style.display = 'none';
  document.getElementById('game').style.display = 'block';
  initGame();
};

function initGame() {
  const canvas = document.getElementById('gameCanvas');
  
  // Scene
  scene = new THREE.Scene();
  
  // Skybox gradient
  const skyGeo = new THREE.SphereGeometry(500, 32, 32);
  const skyMat = new THREE.ShaderMaterial({
    uniforms: {
      topColor: { value: new THREE.Color(0x0077ff) },
      bottomColor: { value: new THREE.Color(0xffffff) },
      offset: { value: 20 },
      exponent: { value: 0.6 }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      uniform float offset;
      uniform float exponent;
      varying vec3 vWorldPosition;
      void main() {
        float h = normalize(vWorldPosition + offset).y;
        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
      }
    `,
    side: THREE.BackSide
  });
  scene.add(new THREE.Mesh(skyGeo, skyMat));
  
  scene.fog = new THREE.FogExp2(0x88bbee, 0.0015);
  
  // Camera
  camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
  
  // Renderer - Maximum quality
  renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  
  // Post-processing
  composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  
  const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.3, 0.4, 0.85);
  composer.addPass(bloomPass);
  
  const smaaPass = new SMAAPass(window.innerWidth, window.innerHeight);
  composer.addPass(smaaPass);
  
  // Lighting - Cinematic quality
  const ambient = new THREE.AmbientLight(0x404060, 0.3);
  scene.add(ambient);
  
  sun = new THREE.DirectionalLight(0xffffee, 2.0);
  sun.position.set(80, 120, 60);
  sun.castShadow = true;
  sun.shadow.mapSize.width = 4096;
  sun.shadow.mapSize.height = 4096;
  sun.shadow.camera.near = 10;
  sun.shadow.camera.far = 400;
  sun.shadow.camera.left = -150;
  sun.shadow.camera.right = 150;
  sun.shadow.camera.top = 150;
  sun.shadow.camera.bottom = -150;
  sun.shadow.bias = -0.0001;
  sun.shadow.normalBias = 0.02;
  scene.add(sun);
  
  sunTarget = new THREE.Object3D();
  scene.add(sunTarget);
  sun.target = sunTarget;
  
  const hemi = new THREE.HemisphereLight(0x87CEEB, 0x3d5c2e, 0.5);
  scene.add(hemi);
  
  // Ground with detail
  createGround();
  createWorld();
  createPlayer();
  setupControls(canvas);
  
  clock = new THREE.Clock();
  log('Welcome, ' + cfg.name + '! Your adventure begins...', 'system');
  
  gameLoop();
}


function createGround() {
  // Main terrain
  const groundGeo = new THREE.PlaneGeometry(800, 800, 128, 128);
  
  // Add height variation
  const vertices = groundGeo.attributes.position.array;
  for (let i = 0; i < vertices.length; i += 3) {
    const x = vertices[i];
    const y = vertices[i + 1];
    vertices[i + 2] = Math.sin(x * 0.02) * Math.cos(y * 0.02) * 2 + Math.random() * 0.3;
  }
  groundGeo.computeVertexNormals();
  
  const groundMat = new THREE.MeshStandardMaterial({
    color: 0x4a7c3f,
    roughness: 0.9,
    metalness: 0.0,
    flatShading: false
  });
  
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);
  
  // Dirt paths
  createPath(0, 0, 800, 18);
  createPath(0, 0, 18, 800);
  createPath(-120, 120, 250, 12);
  createPath(120, -120, 12, 250);
}

function createPath(x, z, w, d) {
  const geo = new THREE.PlaneGeometry(w, d);
  const mat = new THREE.MeshStandardMaterial({ 
    color: 0x8B7355, 
    roughness: 0.95,
    metalness: 0.0
  });
  const path = new THREE.Mesh(geo, mat);
  path.rotation.x = -Math.PI / 2;
  path.position.set(x, 0.05, z);
  path.receiveShadow = true;
  scene.add(path);
}

function createWorld() {
  // Village buildings - detailed
  createDetailedBuilding(-70, -70, 30, 22, 30, 0x8B4513, 'The Golden Tavern', 'tavern');
  createDetailedBuilding(80, -60, 35, 26, 35, 0x4a4a4a, 'Ironforge Smithy', 'smithy');
  createDetailedBuilding(-90, 70, 50, 45, 45, 0x3d4f5f, 'Castle Keep', 'castle');
  createDetailedBuilding(100, 80, 28, 18, 28, 0x8B7355, 'Market Hall', 'market');
  createDetailedBuilding(0, -140, 30, 35, 40, 0x5a5a6a, 'Church of Light', 'church');
  
  // Village houses
  const housePositions = [
    [-140, -40], [140, -30], [-50, 140], [50, -180], [-180, 0],
    [180, 40], [-30, 180], [160, 160], [-160, -140], [0, 80]
  ];
  housePositions.forEach(([hx, hz]) => {
    createDetailedBuilding(hx, hz, 16 + Math.random() * 8, 14 + Math.random() * 4, 16 + Math.random() * 8, 0x6d5c4a, 'Village House', 'house');
  });
  
  // Dense forest
  for (let i = 0; i < 150; i++) {
    const x = (Math.random() - 0.5) * 700;
    const z = (Math.random() - 0.5) * 700;
    if (Math.abs(x) > 45 || Math.abs(z) > 45) {
      createDetailedTree(x, z);
    }
  }
  
  // Rocks and boulders
  for (let i = 0; i < 60; i++) {
    const x = (Math.random() - 0.5) * 600;
    const z = (Math.random() - 0.5) * 600;
    createRock(x, z);
  }
  
  // Grass patches
  for (let i = 0; i < 200; i++) {
    const x = (Math.random() - 0.5) * 600;
    const z = (Math.random() - 0.5) * 600;
    createGrass(x, z);
  }
  
  // Enemies
  const enemyTypes = [
    { name: 'Bandit Scout', color: 0x8B0000, hp: 50, dmg: 8, spd: 4, hostile: true },
    { name: 'Bandit Raider', color: 0xB22222, hp: 80, dmg: 12, spd: 3.5, hostile: true },
    { name: 'Kingdom Guard', color: 0x4169E1, hp: 100, dmg: 10, spd: 3, hostile: false },
    { name: 'Wild Wolf', color: 0x444444, hp: 40, dmg: 15, spd: 6, hostile: true }
  ];
  
  for (let i = 0; i < 20; i++) {
    const x = (Math.random() - 0.5) * 450;
    const z = (Math.random() - 0.5) * 450;
    if (Math.abs(x) > 50 || Math.abs(z) > 50) {
      createEnemy(x, z, enemyTypes[Math.floor(Math.random() * enemyTypes.length)]);
    }
  }
  
  // NPCs
  createNPC(-65, -65, 'Merchant Aldric', 0xDAA520, 'trade');
  createNPC(85, -55, 'Blacksmith Gorn', 0x708090, 'craft');
  createNPC(-85, 75, 'Lord Commander', 0x9370DB, 'quest');
  createNPC(5, -135, 'Healer Miriam', 0x98FB98, 'heal');
  createNPC(105, 85, 'Trader Marcus', 0xDEB887, 'trade');
  
  // Items
  for (let i = 0; i < 40; i++) {
    const x = (Math.random() - 0.5) * 500;
    const z = (Math.random() - 0.5) * 500;
    createItem(x, z);
  }
}


function createDetailedBuilding(x, z, w, h, d, color, name, type) {
  const group = new THREE.Group();
  
  // Foundation
  const foundGeo = new THREE.BoxGeometry(w + 2, 1, d + 2);
  const foundMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.9 });
  const foundation = new THREE.Mesh(foundGeo, foundMat);
  foundation.position.y = 0.5;
  foundation.castShadow = true;
  foundation.receiveShadow = true;
  group.add(foundation);
  
  // Main structure with texture-like appearance
  const bodyGeo = new THREE.BoxGeometry(w, h, d);
  const bodyMat = new THREE.MeshStandardMaterial({ 
    color: color, 
    roughness: 0.85,
    metalness: 0.05
  });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = h / 2 + 1;
  body.castShadow = true;
  body.receiveShadow = true;
  group.add(body);
  
  // Timber frame details
  const timberMat = new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.9 });
  
  // Vertical beams
  [-1, 1].forEach(side => {
    const beam = new THREE.Mesh(new THREE.BoxGeometry(0.8, h, 0.8), timberMat);
    beam.position.set(side * (w/2 - 0.4), h/2 + 1, d/2 - 0.4);
    beam.castShadow = true;
    group.add(beam);
    
    const beam2 = new THREE.Mesh(new THREE.BoxGeometry(0.8, h, 0.8), timberMat);
    beam2.position.set(side * (w/2 - 0.4), h/2 + 1, -d/2 + 0.4);
    beam2.castShadow = true;
    group.add(beam2);
  });
  
  // Horizontal beam
  const hBeam = new THREE.Mesh(new THREE.BoxGeometry(w, 0.6, 0.6), timberMat);
  hBeam.position.set(0, h * 0.6 + 1, d/2);
  group.add(hBeam);
  
  // Roof
  const roofHeight = h * 0.5;
  const roofGeo = new THREE.ConeGeometry(Math.max(w, d) * 0.8, roofHeight, 4);
  const roofMat = new THREE.MeshStandardMaterial({ 
    color: type === 'castle' ? 0x2c3e50 : 0x8B0000, 
    roughness: 0.7 
  });
  const roof = new THREE.Mesh(roofGeo, roofMat);
  roof.position.y = h + roofHeight/2 + 1;
  roof.rotation.y = Math.PI / 4;
  roof.castShadow = true;
  group.add(roof);
  
  // Door
  const doorGeo = new THREE.BoxGeometry(w * 0.18, h * 0.45, 0.4);
  const doorMat = new THREE.MeshStandardMaterial({ color: 0x2d1f14, roughness: 0.8 });
  const door = new THREE.Mesh(doorGeo, doorMat);
  door.position.set(0, h * 0.225 + 1, d/2 + 0.15);
  group.add(door);
  
  // Door frame
  const frameMat = new THREE.MeshStandardMaterial({ color: 0x1a1108, roughness: 0.9 });
  const frameTop = new THREE.Mesh(new THREE.BoxGeometry(w * 0.22, 0.3, 0.5), frameMat);
  frameTop.position.set(0, h * 0.45 + 1.15, d/2 + 0.2);
  group.add(frameTop);
  
  // Windows with glow
  const winMat = new THREE.MeshStandardMaterial({ 
    color: 0xffeebb, 
    emissive: 0xffaa44,
    emissiveIntensity: 0.3,
    roughness: 0.3
  });
  
  [-1, 1].forEach(side => {
    const win = new THREE.Mesh(new THREE.BoxGeometry(w * 0.12, h * 0.15, 0.3), winMat);
    win.position.set(side * w * 0.3, h * 0.65 + 1, d/2 + 0.1);
    group.add(win);
  });
  
  // Chimney for tavern/houses
  if (type === 'tavern' || type === 'house') {
    const chimney = new THREE.Mesh(
      new THREE.BoxGeometry(2, 8, 2),
      new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.9 })
    );
    chimney.position.set(w * 0.3, h + 4, -d * 0.3);
    chimney.castShadow = true;
    group.add(chimney);
  }
  
  group.position.set(x, 0, z);
  group.userData = { type: 'building', name };
  scene.add(group);
  buildings.push(group);
}

function createDetailedTree(x, z) {
  const group = new THREE.Group();
  const scale = 0.7 + Math.random() * 0.8;
  const treeType = Math.random();
  
  // Trunk with bark texture effect
  const trunkGeo = new THREE.CylinderGeometry(0.4 * scale, 0.6 * scale, 6 * scale, 12);
  const trunkMat = new THREE.MeshStandardMaterial({ 
    color: 0x4a3520, 
    roughness: 0.95,
    metalness: 0.0
  });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.y = 3 * scale;
  trunk.castShadow = true;
  trunk.receiveShadow = true;
  group.add(trunk);
  
  // Branches
  for (let i = 0; i < 3; i++) {
    const branch = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1 * scale, 0.15 * scale, 2 * scale, 6),
      trunkMat
    );
    branch.position.set(
      Math.cos(i * 2.1) * 0.8 * scale,
      (4 + i) * scale,
      Math.sin(i * 2.1) * 0.8 * scale
    );
    branch.rotation.z = Math.PI / 4;
    branch.rotation.y = i * 2.1;
    group.add(branch);
  }
  
  // Foliage - multiple layers for volume
  const foliageColors = [0x2d5a27, 0x3d7a37, 0x4d8a47];
  
  if (treeType < 0.7) {
    // Deciduous tree
    for (let i = 0; i < 4; i++) {
      const foliageGeo = new THREE.SphereGeometry((3.5 - i * 0.4) * scale, 10, 8);
      const foliageMat = new THREE.MeshStandardMaterial({ 
        color: foliageColors[i % 3], 
        roughness: 0.8 
      });
      const foliage = new THREE.Mesh(foliageGeo, foliageMat);
      foliage.position.set(
        Math.cos(i * 1.5) * 0.5 * scale,
        (6 + i * 1.2) * scale,
        Math.sin(i * 1.5) * 0.5 * scale
      );
      foliage.castShadow = true;
      group.add(foliage);
    }
  } else {
    // Pine tree
    for (let i = 0; i < 5; i++) {
      const coneGeo = new THREE.ConeGeometry((3 - i * 0.4) * scale, 3 * scale, 8);
      const coneMat = new THREE.MeshStandardMaterial({ 
        color: 0x1a4a1a, 
        roughness: 0.85 
      });
      const cone = new THREE.Mesh(coneGeo, coneMat);
      cone.position.y = (4 + i * 2) * scale;
      cone.castShadow = true;
      group.add(cone);
    }
  }
  
  group.position.set(x, 0, z);
  scene.add(group);
}

function createRock(x, z) {
  const size = 0.8 + Math.random() * 2.5;
  const geo = new THREE.DodecahedronGeometry(size, 1);
  
  // Deform for natural look
  const vertices = geo.attributes.position.array;
  for (let i = 0; i < vertices.length; i += 3) {
    vertices[i] += (Math.random() - 0.5) * 0.3;
    vertices[i + 1] += (Math.random() - 0.5) * 0.3;
    vertices[i + 2] += (Math.random() - 0.5) * 0.3;
  }
  geo.computeVertexNormals();
  
  const mat = new THREE.MeshStandardMaterial({ 
    color: 0x6a6a6a, 
    roughness: 0.95,
    metalness: 0.1
  });
  const rock = new THREE.Mesh(geo, mat);
  rock.position.set(x, size * 0.3, z);
  rock.rotation.set(Math.random(), Math.random(), Math.random());
  rock.castShadow = true;
  rock.receiveShadow = true;
  scene.add(rock);
}

function createGrass(x, z) {
  const group = new THREE.Group();
  const grassMat = new THREE.MeshStandardMaterial({ 
    color: 0x4a8a3a, 
    roughness: 0.9,
    side: THREE.DoubleSide
  });
  
  for (let i = 0; i < 5; i++) {
    const blade = new THREE.Mesh(
      new THREE.PlaneGeometry(0.1, 0.5 + Math.random() * 0.3),
      grassMat
    );
    blade.position.set(
      (Math.random() - 0.5) * 0.5,
      0.25,
      (Math.random() - 0.5) * 0.5
    );
    blade.rotation.y = Math.random() * Math.PI;
    blade.rotation.x = -0.1 + Math.random() * 0.2;
    group.add(blade);
  }
  
  group.position.set(x, 0, z);
  scene.add(group);
}


function createPlayer() {
  const group = new THREE.Group();
  
  // Body
  const bodyGeo = new THREE.CylinderGeometry(0.35, 0.4, 1.4, 16);
  const bodyMat = new THREE.MeshStandardMaterial({ 
    color: cfg.color, 
    roughness: 0.5,
    metalness: 0.2
  });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.7;
  body.castShadow = true;
  group.add(body);
  
  // Head
  const headGeo = new THREE.SphereGeometry(0.28, 16, 12);
  const headMat = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.6 });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.65;
  head.castShadow = true;
  group.add(head);
  
  // Arms
  const armMat = new THREE.MeshStandardMaterial({ color: cfg.color, roughness: 0.5 });
  [-1, 1].forEach(side => {
    const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.8, 8), armMat);
    arm.position.set(side * 0.45, 0.9, 0);
    arm.rotation.z = side * 0.2;
    arm.castShadow = true;
    group.add(arm);
  });
  
  player = group;
  player.position.set(0, 0, 0);
  scene.add(player);
}

function createEnemy(x, z, type) {
  const group = new THREE.Group();
  
  // Body
  const bodyGeo = new THREE.CylinderGeometry(0.35, 0.42, 1.3, 12);
  const bodyMat = new THREE.MeshStandardMaterial({ 
    color: type.color, 
    roughness: 0.6,
    metalness: 0.1
  });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.65;
  body.castShadow = true;
  group.add(body);
  
  // Head
  const headGeo = new THREE.SphereGeometry(0.24, 12, 10);
  const headMat = new THREE.MeshStandardMaterial({ 
    color: type.hostile ? 0x6a3030 : 0x4a5a7a, 
    roughness: 0.6 
  });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.45;
  head.castShadow = true;
  group.add(head);
  
  // Health bar
  const hpBgGeo = new THREE.PlaneGeometry(1.4, 0.15);
  const hpBgMat = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide });
  const hpBg = new THREE.Mesh(hpBgGeo, hpBgMat);
  hpBg.position.y = 2.1;
  group.add(hpBg);
  
  const hpGeo = new THREE.PlaneGeometry(1.35, 0.12);
  const hpMat = new THREE.MeshBasicMaterial({ 
    color: type.hostile ? 0xff3333 : 0x3388ff, 
    side: THREE.DoubleSide 
  });
  const hpBar = new THREE.Mesh(hpGeo, hpMat);
  hpBar.position.y = 2.1;
  hpBar.position.z = 0.01;
  group.add(hpBar);
  
  group.position.set(x, 0, z);
  group.userData = {
    type: 'enemy',
    enemyType: type,
    hp: type.hp,
    maxHp: type.hp,
    state: 'patrol',
    vx: (Math.random() - 0.5) * 2,
    vz: (Math.random() - 0.5) * 2,
    hpBar: hpBar
  };
  
  scene.add(group);
  enemies.push(group);
}

function createNPC(x, z, name, color, role) {
  const group = new THREE.Group();
  
  // Body
  const bodyGeo = new THREE.CylinderGeometry(0.32, 0.38, 1.35, 14);
  const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.5, metalness: 0.1 });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.68;
  body.castShadow = true;
  group.add(body);
  
  // Head
  const headGeo = new THREE.SphereGeometry(0.22, 14, 10);
  const headMat = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.6 });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.55;
  head.castShadow = true;
  group.add(head);
  
  // Quest indicator with glow
  const indGeo = new THREE.OctahedronGeometry(0.18, 0);
  const indMat = new THREE.MeshStandardMaterial({ 
    color: 0xffff00, 
    emissive: 0xffaa00,
    emissiveIntensity: 0.8,
    roughness: 0.3
  });
  const indicator = new THREE.Mesh(indGeo, indMat);
  indicator.position.y = 2.2;
  group.add(indicator);
  group.userData.indicator = indicator;
  
  // Point light for NPC
  const light = new THREE.PointLight(0xffaa44, 0.5, 5);
  light.position.y = 2;
  group.add(light);
  
  group.position.set(x, 0, z);
  group.userData.type = 'npc';
  group.userData.name = name;
  group.userData.role = role;
  
  scene.add(group);
  npcs.push(group);
}

function createItem(x, z) {
  const types = [
    { name: 'Apple', color: 0xff2222, effect: 'hunger', value: 15, emissive: 0x440000 },
    { name: 'Bread', color: 0xdaa520, effect: 'hunger', value: 25, emissive: 0x442200 },
    { name: 'Health Potion', color: 0xff44ff, effect: 'health', value: 40, emissive: 0x440044 },
    { name: 'Gold Coin', color: 0xffd700, effect: 'gold', value: 10, emissive: 0x444400 },
    { name: 'Iron Sword', color: 0xcccccc, effect: 'weapon', value: 5, emissive: 0x333333 }
  ];
  const type = types[Math.floor(Math.random() * types.length)];
  
  const geo = new THREE.OctahedronGeometry(0.35, 0);
  const mat = new THREE.MeshStandardMaterial({ 
    color: type.color, 
    emissive: type.emissive,
    emissiveIntensity: 0.6,
    roughness: 0.2,
    metalness: 0.6
  });
  const item = new THREE.Mesh(geo, mat);
  item.position.set(x, 0.6, z);
  item.castShadow = true;
  item.userData = { type: 'item', itemType: type, collected: false };
  
  // Glow light
  const glow = new THREE.PointLight(type.color, 0.4, 3);
  glow.position.y = 0;
  item.add(glow);
  
  scene.add(item);
  items.push(item);
}


function setupControls(canvas) {
  document.addEventListener('keydown', e => { 
    keys[e.code] = true;
    if (e.code === 'KeyE') handleInteract();
    if (e.code === 'KeyQ') handleAttack();
  });
  document.addEventListener('keyup', e => { keys[e.code] = false; });
  
  document.addEventListener('mousemove', e => {
    if (isLocked) {
      playerYaw -= e.movementX * 0.002;
      playerPitch -= e.movementY * 0.001;
      playerPitch = Math.max(-0.8, Math.min(0.8, playerPitch));
    }
  });
  
  canvas.addEventListener('click', () => canvas.requestPointerLock());
  document.addEventListener('pointerlockchange', () => {
    isLocked = document.pointerLockElement === canvas;
  });
  
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  });
}

function handleInteract() {
  for (const npc of npcs) {
    if (player.position.distanceTo(npc.position) < 4) {
      const dialogs = {
        trade: '"Welcome! I have the finest wares in all the land."',
        craft: '"Need steel forged? I am the greatest smith you will find!"',
        quest: '"Brave soul! The bandits grow bolder. Will you aid us?"',
        heal: '"May the light bless you. Let me tend to your wounds."'
      };
      log(npc.userData.name + ': ' + dialogs[npc.userData.role], 'ai');
      if (npc.userData.role === 'heal' && hp < maxHp) {
        hp = Math.min(maxHp, hp + 50);
        log('You feel rejuvenated! +50 HP', 'system');
      }
      return;
    }
  }
  
  for (const item of items) {
    if (item.userData.collected) continue;
    if (player.position.distanceTo(item.position) < 3) {
      item.userData.collected = true;
      item.visible = false;
      const type = item.userData.itemType;
      log('Collected: ' + type.name, 'quest');
      if (type.effect === 'hunger') hunger = Math.min(100, hunger + type.value);
      if (type.effect === 'health') hp = Math.min(maxHp, hp + type.value);
      return;
    }
  }
}

function handleAttack() {
  for (const enemy of enemies) {
    if (enemy.userData.hp <= 0) continue;
    if (player.position.distanceTo(enemy.position) < 4) {
      const dmg = cfg.dmg + Math.floor(Math.random() * 8);
      enemy.userData.hp -= dmg;
      log('Hit ' + enemy.userData.enemyType.name + ' for ' + dmg + ' damage!', 'combat');
      enemy.userData.hpBar.scale.x = Math.max(0, enemy.userData.hp / enemy.userData.maxHp);
      enemy.userData.state = 'chase';
      if (enemy.userData.hp <= 0) {
        log(enemy.userData.enemyType.name + ' defeated!', 'combat');
        heat.bandits = Math.min(100, heat.bandits + 10);
      }
      return;
    }
  }
}

function gameLoop() {
  requestAnimationFrame(gameLoop);
  const dt = Math.min(clock.getDelta(), 0.05);
  
  // Player movement
  let moveX = 0, moveZ = 0;
  if (keys.KeyW || keys.ArrowUp) moveZ = -1;
  if (keys.KeyS || keys.ArrowDown) moveZ = 1;
  if (keys.KeyA || keys.ArrowLeft) moveX = -1;
  if (keys.KeyD || keys.ArrowRight) moveX = 1;
  
  const running = keys.ShiftLeft && stamina > 0;
  const speed = (running ? cfg.spd * 1.8 : cfg.spd) * dt;
  
  if (moveX || moveZ) {
    const angle = Math.atan2(moveX, moveZ) + playerYaw;
    player.position.x += Math.sin(angle) * speed;
    player.position.z += Math.cos(angle) * speed;
    if (running) stamina = Math.max(0, stamina - 18 * dt);
  }
  
  if (!running) stamina = Math.min(100, stamina + 10 * dt);
  hunger = Math.max(0, hunger - 0.15 * dt);
  if (hunger <= 0) hp -= dt * 3;
  
  player.position.x = Math.max(-380, Math.min(380, player.position.x));
  player.position.z = Math.max(-380, Math.min(380, player.position.z));
  player.rotation.y = playerYaw;
  
  // Camera
  const camDist = 5;
  const camHeight = 2.5;
  camera.position.x = player.position.x - Math.sin(playerYaw) * camDist;
  camera.position.y = player.position.y + camHeight - playerPitch * 2;
  camera.position.z = player.position.z - Math.cos(playerYaw) * camDist;
  camera.lookAt(player.position.x, player.position.y + 1.5, player.position.z);
  
  // Sun follows player
  sun.position.set(player.position.x + 80, 120, player.position.z + 60);
  sunTarget.position.copy(player.position);
  
  // Enemy AI
  updateEnemies(dt);
  
  // Animate NPCs
  npcs.forEach(npc => {
    if (npc.userData.indicator) {
      npc.userData.indicator.rotation.y += dt * 2;
      npc.userData.indicator.position.y = 2.2 + Math.sin(Date.now() * 0.004) * 0.15;
    }
  });
  
  // Animate items
  items.forEach(item => {
    if (!item.userData.collected) {
      item.position.y = 0.6 + Math.sin(Date.now() * 0.003 + item.position.x) * 0.2;
      item.rotation.y += dt * 2;
      item.rotation.x += dt * 0.8;
    }
  });
  
  // Time
  gameTime += dt * 0.03;
  if (gameTime >= 24) { gameTime = 0; day++; log('Day ' + day + ' dawns...', 'system'); }
  
  // Heat decay
  heat.kingdom = Math.max(0, heat.kingdom - 0.1 * dt);
  heat.bandits = Math.max(0, heat.bandits - 0.1 * dt);
  
  updateHUD();
  updateMinimap();
  
  if (hp <= 0) {
    log('You have fallen! Respawning...', 'combat');
    hp = maxHp;
    stamina = 100;
    player.position.set(0, 0, 0);
  }
  
  composer.render();
}

function updateEnemies(dt) {
  enemies.forEach(enemy => {
    if (enemy.userData.hp <= 0) { enemy.visible = false; return; }
    
    const data = enemy.userData;
    const type = data.enemyType;
    const dist = player.position.distanceTo(enemy.position);
    
    // Face health bars to camera
    if (enemy.children[2]) enemy.children[2].lookAt(camera.position);
    if (enemy.children[3]) enemy.children[3].lookAt(camera.position);
    
    if (type.hostile) {
      if (dist < 40 && dist > 2.5) {
        const dir = player.position.clone().sub(enemy.position).normalize();
        enemy.position.x += dir.x * type.spd * dt;
        enemy.position.z += dir.z * type.spd * dt;
        enemy.lookAt(player.position.x, enemy.position.y, player.position.z);
        data.state = 'chase';
      } else if (dist <= 2.5) {
        if (Math.random() < dt * 1.2) {
          const dmg = Math.max(1, type.dmg - Math.floor(cfg.armor * type.dmg));
          hp -= dmg;
          log(type.name + ' hits you for ' + dmg + ' damage!', 'combat');
        }
      } else {
        enemy.position.x += data.vx * dt;
        enemy.position.z += data.vz * dt;
        if (Math.abs(enemy.position.x) > 200) data.vx *= -1;
        if (Math.abs(enemy.position.z) > 200) data.vz *= -1;
      }
    } else {
      enemy.position.x += data.vx * 0.3 * dt;
      enemy.position.z += data.vz * 0.3 * dt;
      if (Math.abs(enemy.position.x) > 120) data.vx *= -1;
      if (Math.abs(enemy.position.z) > 120) data.vz *= -1;
    }
  });
}


function updateHUD() {
  document.getElementById('hp').style.width = (hp / maxHp * 100) + '%';
  document.getElementById('st').style.width = stamina + '%';
  document.getElementById('hu').style.width = hunger + '%';
  document.getElementById('hp-text').textContent = Math.floor(hp) + '/' + maxHp;
  document.getElementById('st-text').textContent = Math.floor(stamina) + '%';
  document.getElementById('hu-text').textContent = Math.floor(hunger) + '%';
  
  const hours = Math.floor(gameTime);
  const mins = Math.floor((gameTime % 1) * 60);
  document.getElementById('day').textContent = 'Day ' + day + ' | ' + 
    String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
  
  let weather = '‚òÄÔ∏è Clear';
  if (gameTime < 6 || gameTime > 20) weather = 'üåô Night';
  else if (gameTime > 18) weather = 'üåÖ Sunset';
  else if (gameTime < 8) weather = 'üåÑ Dawn';
  document.getElementById('weather').textContent = weather + ' | 22¬∞C';
  
  const hk = document.getElementById('h-kingdom');
  const hb = document.getElementById('h-bandits');
  hk.textContent = heat.kingdom < 25 ? 'CALM' : heat.kingdom < 50 ? 'ALERT' : 'HUNTING';
  hk.className = 'heat-tag ' + (heat.kingdom < 25 ? 'calm' : heat.kingdom < 50 ? 'alert' : 'hunting');
  hb.textContent = heat.bandits < 25 ? 'CALM' : heat.bandits < 50 ? 'ALERT' : 'HUNTING';
  hb.className = 'heat-tag ' + (heat.bandits < 25 ? 'calm' : heat.bandits < 50 ? 'alert' : 'hunting');
}

function updateMinimap() {
  const canvas = document.getElementById('minimap');
  const ctx = canvas.getContext('2d');
  const size = 200;
  const scale = 0.3;
  const cx = size / 2, cy = size / 2;
  
  // Circular clip
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, size/2 - 3, 0, Math.PI * 2);
  ctx.clip();
  
  // Background
  ctx.fillStyle = '#0a1a0a';
  ctx.fillRect(0, 0, size, size);
  
  // Grid
  ctx.strokeStyle = '#1a2a1a';
  ctx.lineWidth = 1;
  for (let i = -200; i <= 200; i += 40) {
    const gx = cx + i * scale;
    ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, size); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, gx); ctx.lineTo(size, gx); ctx.stroke();
  }
  
  const px = player.position.x;
  const pz = player.position.z;
  
  // Buildings
  ctx.fillStyle = '#4a4a3a';
  buildings.forEach(b => {
    const x = cx + (b.position.x - px) * scale;
    const z = cy + (b.position.z - pz) * scale;
    const dist = Math.sqrt((x-cx)**2 + (z-cy)**2);
    if (dist < size/2 - 5) {
      ctx.fillRect(x - 6, z - 6, 12, 12);
    }
  });
  
  // Enemies
  enemies.forEach(e => {
    if (e.userData.hp <= 0) return;
    const x = cx + (e.position.x - px) * scale;
    const z = cy + (e.position.z - pz) * scale;
    const dist = Math.sqrt((x-cx)**2 + (z-cy)**2);
    if (dist < size/2 - 5) {
      ctx.fillStyle = e.userData.enemyType.hostile ? '#ff4444' : '#4488ff';
      ctx.beginPath(); ctx.arc(x, z, 4, 0, Math.PI * 2); ctx.fill();
    }
  });
  
  // NPCs
  ctx.fillStyle = '#44ff44';
  npcs.forEach(n => {
    const x = cx + (n.position.x - px) * scale;
    const z = cy + (n.position.z - pz) * scale;
    const dist = Math.sqrt((x-cx)**2 + (z-cy)**2);
    if (dist < size/2 - 5) {
      ctx.beginPath(); ctx.arc(x, z, 5, 0, Math.PI * 2); ctx.fill();
    }
  });
  
  // Items
  ctx.fillStyle = '#ffff44';
  items.forEach(i => {
    if (i.userData.collected) return;
    const x = cx + (i.position.x - px) * scale;
    const z = cy + (i.position.z - pz) * scale;
    const dist = Math.sqrt((x-cx)**2 + (z-cy)**2);
    if (dist < size/2 - 5) {
      ctx.fillRect(x - 2, z - 2, 4, 4);
    }
  });
  
  ctx.restore();
  
  // Player at center
  ctx.fillStyle = '#ffd700';
  ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI * 2); ctx.fill();
  
  // Direction
  ctx.strokeStyle = '#ffd700';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx - Math.sin(playerYaw) * 20, cy - Math.cos(playerYaw) * 20);
  ctx.stroke();
  
  // Border
  ctx.strokeStyle = '#ffd700';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(cx, cy, size/2 - 2, 0, Math.PI * 2);
  ctx.stroke();
}

function log(msg, type = 'system') {
  const el = document.getElementById('log-entries');
  const div = document.createElement('div');
  div.className = 'log-entry log-' + type;
  const hours = Math.floor(gameTime);
  const mins = Math.floor((gameTime % 1) * 60);
  div.textContent = '[' + String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0') + '] ' + msg;
  el.insertBefore(div, el.firstChild);
  while (el.children.length > 25) el.removeChild(el.lastChild);
}

console.log('‚öîÔ∏è Surviving The World‚Ñ¢ - AAA Next-Gen Engine');
console.log('üéÆ Post-Processing: Bloom + SMAA | Dynamic Shadows | HDR Lighting');
</script>
</body>
</html>
