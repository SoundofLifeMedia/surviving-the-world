<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Surviving The World‚Ñ¢ - AAA Open World</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;font-family:'Segoe UI',Arial,sans-serif;overflow:hidden;color:#fff}
#menu{position:fixed;inset:0;background:linear-gradient(135deg,#0a0a15 0%,#1a1a2e 50%,#0a0a15 100%);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:1000}
.logo{font-size:3.5em;color:#ffd700;text-shadow:0 0 40px rgba(255,215,0,0.6),0 4px 8px rgba(0,0,0,0.8);margin-bottom:10px;font-weight:bold}
.subtitle{color:#888;margin-bottom:40px;letter-spacing:3px;font-size:14px}
.chars{display:flex;gap:20px;flex-wrap:wrap;justify-content:center;max-width:900px}
.char{width:150px;padding:25px 15px;background:linear-gradient(180deg,#1a1a2e,#12121f);border:2px solid #333;border-radius:15px;cursor:pointer;text-align:center;transition:all .3s ease}
.char:hover{border-color:#ffd700;transform:translateY(-8px);box-shadow:0 15px 40px rgba(255,215,0,0.3)}
.char .icon{font-size:48px;margin-bottom:12px}
.char .name{font-weight:bold;font-size:16px;margin-bottom:8px;color:#fff}
.char .stats{color:#888;font-size:11px;line-height:1.4}
.hint{color:#555;margin-top:40px;font-size:12px}
#game{display:none;position:fixed;inset:0}
#gameCanvas{width:100%;height:100%;display:block}
#hud{position:fixed;top:20px;left:20px;z-index:100}
.stat{margin-bottom:10px;display:flex;align-items:center;gap:10px}
.stat-icon{font-size:18px;filter:drop-shadow(0 2px 4px rgba(0,0,0,0.5))}
.stat-bar{width:180px;height:20px;background:rgba(0,0,0,0.7);border-radius:10px;overflow:hidden;border:2px solid rgba(255,255,255,0.2)}
.stat-fill{height:100%;border-radius:8px;transition:width .3s;box-shadow:0 0 10px currentColor}
.hp-fill{background:linear-gradient(90deg,#8B0000,#dc3545,#ff6b6b);color:#ff6b6b}
.st-fill{background:linear-gradient(90deg,#0d5016,#28a745,#5dd879);color:#5dd879}
.hu-fill{background:linear-gradient(90deg,#8B4513,#fd7e14,#ffc107);color:#ffc107}
.stat-text{font-size:12px;color:#fff;min-width:60px;text-shadow:0 1px 2px rgba(0,0,0,0.8)}
#info{position:fixed;top:20px;right:20px;text-align:right;z-index:100;background:rgba(0,0,0,0.5);padding:15px;border-radius:10px}
#day{font-size:22px;color:#ffd700;font-weight:bold}
#weather{font-size:14px;color:#ccc;margin-top:5px}
#heat{margin-top:12px;font-size:12px}
.heat-row{margin:6px 0;display:flex;align-items:center;justify-content:flex-end;gap:10px}
.heat-tag{padding:5px 14px;border-radius:15px;font-size:11px;font-weight:bold;text-transform:uppercase}
.calm{background:#28a745;color:#fff}.alert{background:#fd7e14;color:#fff}.hunting{background:#dc3545;color:#fff}
#minimap{position:fixed;bottom:20px;right:20px;width:180px;height:180px;background:rgba(0,0,0,0.8);border:3px solid #ffd700;border-radius:50%;z-index:100}
#log{position:fixed;bottom:20px;left:20px;width:320px;max-height:180px;background:rgba(0,0,0,0.8);border-radius:12px;padding:12px;z-index:100;overflow-y:auto}
#log-title{color:#ffd700;margin-bottom:8px;font-weight:bold;font-size:13px}
.log-entry{padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.1);color:#aaa;font-size:11px}
.log-combat{color:#ff6b6b}.log-quest{color:#ffd700}.log-ai{color:#5bc0de}.log-system{color:#5dd879}
#controls{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);padding:10px 25px;border-radius:25px;z-index:100;font-size:11px;color:#888}
#crosshair{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:100;pointer-events:none;width:24px;height:24px}
#crosshair::before,#crosshair::after{content:'';position:absolute;background:rgba(255,255,255,0.8)}
#crosshair::before{width:2px;height:24px;left:11px;top:0}
#crosshair::after{width:24px;height:2px;top:11px;left:0}
</style>
</head>
<body>
<div id="menu">
<div class="logo">‚öîÔ∏è SURVIVING THE WORLD‚Ñ¢</div>
<div class="subtitle">MODERN WARFARE QUALITY ENGINE</div>
<div class="chars">
<div class="char" onclick="startGame(0)"><div class="icon">‚öîÔ∏è</div><div class="name">Warrior</div><div class="stats">HP: 150 | DMG: 25<br>Speed: 5 | Armor: High</div></div>
<div class="char" onclick="startGame(1)"><div class="icon">üèπ</div><div class="name">Ranger</div><div class="stats">HP: 100 | DMG: 20<br>Speed: 7 | Perception+</div></div>
<div class="char" onclick="startGame(2)"><div class="icon">üó°Ô∏è</div><div class="name">Assassin</div><div class="stats">HP: 80 | DMG: 35<br>Speed: 9 | Stealth+</div></div>
<div class="char" onclick="startGame(3)"><div class="icon">üõ°Ô∏è</div><div class="name">Tank</div><div class="stats">HP: 200 | DMG: 15<br>Speed: 4 | Armor: Max</div></div>
<div class="char" onclick="startGame(4)"><div class="icon">üßô</div><div class="name">Survivor</div><div class="stats">HP: 120 | DMG: 18<br>Speed: 5 | Hunger-</div></div>
</div>
<div class="hint">WASD = Move | Mouse = Look | SHIFT = Sprint | SPACE = Jump | E = Interact | Q = Attack</div>
</div>
<div id="game">
<canvas id="gameCanvas"></canvas>
<div id="crosshair"></div>
<div id="hud">
<div class="stat"><span class="stat-icon">‚ù§Ô∏è</span><div class="stat-bar"><div class="stat-fill hp-fill" id="hp"></div></div><span class="stat-text" id="hp-text">150/150</span></div>
<div class="stat"><span class="stat-icon">‚ö°</span><div class="stat-bar"><div class="stat-fill st-fill" id="st"></div></div><span class="stat-text" id="st-text">100%</span></div>
<div class="stat"><span class="stat-icon">üçñ</span><div class="stat-bar"><div class="stat-fill hu-fill" id="hu"></div></div><span class="stat-text" id="hu-text">80%</span></div>
</div>
<div id="info"><div id="day">Day 1 | 06:00</div><div id="weather">‚òÄÔ∏è Clear | 22¬∞C</div>
<div id="heat"><div class="heat-row">Kingdom <span class="heat-tag calm" id="h-kingdom">CALM</span></div>
<div class="heat-row">Bandits <span class="heat-tag alert" id="h-bandits">ALERT</span></div></div></div>
<canvas id="minimap" width="180" height="180"></canvas>
<div id="log"><div id="log-title">üìú Adventure Log</div><div id="log-entries"></div></div>
<div id="controls">WASD Move | Mouse Look | SHIFT Sprint | SPACE Jump | E Interact | Q Attack</div>
</div>

<script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js","three/addons/":"https://unpkg.com/three@0.160.0/examples/jsm/"}}</script>
<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';

// SURVIVING THE WORLD‚Ñ¢ - OPTIMIZED AAA ENGINE
let scene, camera, renderer, composer, clock;
let player, playerYaw = 0, playerPitch = 0;
let keys = {}, enemies = [], npcs = [], items = [], buildings = [];
let hp = 100, maxHp = 100, stamina = 100, hunger = 80;
let day = 1, gameTime = 8;
let heat = { kingdom: 0, bandits: 25 };
let isLocked = false;
let sun, groundMesh, raycaster;
let playerVelocityY = 0, isGrounded = true;
const GRAVITY = 30, JUMP_FORCE = 10;

const CHARS = [
  { name: 'Warrior', color: 0xc0392b, hp: 150, spd: 6, dmg: 25, armor: 0.3 },
  { name: 'Ranger', color: 0x27ae60, hp: 100, spd: 8, dmg: 20, armor: 0.1 },
  { name: 'Assassin', color: 0x8e44ad, hp: 80, spd: 10, dmg: 35, armor: 0.05 },
  { name: 'Tank', color: 0x2980b9, hp: 200, spd: 5, dmg: 15, armor: 0.5 },
  { name: 'Survivor', color: 0xd35400, hp: 120, spd: 6, dmg: 18, armor: 0.2 }
];
let cfg;

window.startGame = function(i) {
  cfg = CHARS[i]; hp = cfg.hp; maxHp = cfg.hp;
  document.getElementById('menu').style.display = 'none';
  document.getElementById('game').style.display = 'block';
  initGame();
};

function initGame() {
  const canvas = document.getElementById('gameCanvas');
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0x87CEEB, 100, 500);
  
  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
  
  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  
  raycaster = new THREE.Raycaster();
  clock = new THREE.Clock();
  
  createLighting();
  createTerrain();
  createWorld();
  createMWPlayer();
  setupPostProcessing();
  setupControls(canvas);
  
  log('Welcome, ' + cfg.name + '! Your adventure begins...', 'system');
  gameLoop();
}

function createLighting() {
  scene.add(new THREE.AmbientLight(0x6688aa, 0.6));
  
  sun = new THREE.DirectionalLight(0xffffee, 2.5);
  sun.position.set(50, 100, 50);
  sun.castShadow = true;
  sun.shadow.mapSize.width = 2048;
  sun.shadow.mapSize.height = 2048;
  sun.shadow.camera.near = 10;
  sun.shadow.camera.far = 300;
  sun.shadow.camera.left = -100;
  sun.shadow.camera.right = 100;
  sun.shadow.camera.top = 100;
  sun.shadow.camera.bottom = -100;
  sun.shadow.bias = -0.0002;
  scene.add(sun);
  
  scene.add(new THREE.HemisphereLight(0x87CEEB, 0x3d5c2e, 0.5));
}

function createTerrain() {
  const groundGeo = new THREE.PlaneGeometry(600, 600, 64, 64);
  const vertices = groundGeo.attributes.position.array;
  for (let i = 0; i < vertices.length; i += 3) {
    const x = vertices[i], y = vertices[i + 1];
    let h = Math.sin(x * 0.015) * Math.cos(y * 0.015) * 4;
    const dist = Math.sqrt(x*x + y*y);
    if (dist < 100) h *= dist / 100;
    vertices[i + 2] = h;
  }
  groundGeo.computeVertexNormals();
  
  groundMesh = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0x4a7c3f, roughness: 0.9 }));
  groundMesh.rotation.x = -Math.PI / 2;
  groundMesh.receiveShadow = true;
  scene.add(groundMesh);
  
  // Paths
  [[0,0,500,10],[0,0,10,500]].forEach(([x,z,w,d]) => {
    const path = new THREE.Mesh(new THREE.PlaneGeometry(w,d), new THREE.MeshStandardMaterial({color:0x6b5344,roughness:0.95}));
    path.rotation.x = -Math.PI/2; path.position.set(x,0.05,z); path.receiveShadow = true;
    scene.add(path);
  });
}

function createWorld() {
  // Buildings - optimized count
  createBuilding(-60, -60, 30, 20, 30, 0x8B4513, 'tavern');
  createBuilding(70, -50, 35, 24, 35, 0x4a4a4a, 'smithy');
  createBuilding(-80, 70, 50, 40, 45, 0x3d4f5f, 'castle');
  createBuilding(90, 70, 28, 16, 28, 0x8B7355, 'market');
  createBuilding(0, -120, 28, 30, 35, 0x5a5a6a, 'church');
  
  [[-120,-40],[120,-30],[-40,120],[40,-150],[-150,0],[150,30],[-20,150],[130,130],[-130,-120],[0,70]].forEach(([x,z]) => {
    createBuilding(x, z, 14+Math.random()*6, 12+Math.random()*4, 14+Math.random()*6, 0x6d5c4a, 'house');
  });
  
  // Trees - reduced for performance (80 instead of 300)
  for (let i = 0; i < 80; i++) {
    const x = (Math.random() - 0.5) * 500, z = (Math.random() - 0.5) * 500;
    if (Math.sqrt(x*x + z*z) > 60) createTree(x, z);
  }
  
  // Rocks - reduced (30 instead of 100)
  for (let i = 0; i < 30; i++) {
    const x = (Math.random() - 0.5) * 400, z = (Math.random() - 0.5) * 400;
    createRock(x, z);
  }
  
  // Enemies
  const enemyTypes = [
    { name: 'Bandit Scout', color: 0x8B0000, hp: 50, dmg: 8, spd: 4, hostile: true },
    { name: 'Bandit Raider', color: 0xB22222, hp: 80, dmg: 12, spd: 3.5, hostile: true },
    { name: 'Kingdom Guard', color: 0x4169E1, hp: 100, dmg: 10, spd: 3, hostile: false },
    { name: 'Wild Wolf', color: 0x444444, hp: 40, dmg: 15, spd: 5, hostile: true }
  ];
  
  for (let i = 0; i < 15; i++) {
    const x = (Math.random() - 0.5) * 350, z = (Math.random() - 0.5) * 350;
    if (Math.abs(x) > 50 || Math.abs(z) > 50) createMWEnemy(x, z, enemyTypes[Math.floor(Math.random() * enemyTypes.length)]);
  }
  
  // NPCs
  createMWNPC(-55, -55, 'Merchant Aldric', 0xDAA520, 'trade');
  createMWNPC(75, -45, 'Blacksmith Gorn', 0x708090, 'craft');
  createMWNPC(-75, 75, 'Lord Commander', 0x9370DB, 'quest');
  createMWNPC(5, -115, 'Healer Miriam', 0x98FB98, 'heal');
  
  // Items - reduced (25 instead of 60)
  for (let i = 0; i < 25; i++) {
    const x = (Math.random() - 0.5) * 400, z = (Math.random() - 0.5) * 400;
    createItem(x, z);
  }
}

function createBuilding(x, z, w, h, d, color, type) {
  const g = new THREE.Group();
  
  // Foundation
  const found = new THREE.Mesh(new THREE.BoxGeometry(w+2, 1, d+2), new THREE.MeshStandardMaterial({color:0x4a4a4a,roughness:0.95}));
  found.position.y = 0.5; found.castShadow = true; found.receiveShadow = true; g.add(found);
  
  // Body
  const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color,roughness:0.8}));
  body.position.y = h/2 + 1; body.castShadow = true; body.receiveShadow = true; g.add(body);
  
  // Roof
  const roof = new THREE.Mesh(new THREE.ConeGeometry(Math.max(w,d)*0.75, h*0.5, 4), new THREE.MeshStandardMaterial({color:type==='castle'?0x2c3e50:0x6b2020,roughness:0.7}));
  roof.position.y = h + h*0.25 + 1; roof.rotation.y = Math.PI/4; roof.castShadow = true; g.add(roof);
  
  // Door
  const door = new THREE.Mesh(new THREE.BoxGeometry(w*0.18, h*0.4, 0.3), new THREE.MeshStandardMaterial({color:0x2d1f14}));
  door.position.set(0, h*0.2+1, d/2+0.1); g.add(door);
  
  // Windows
  const winMat = new THREE.MeshStandardMaterial({color:0xffeedd,emissive:0xffaa44,emissiveIntensity:0.4});
  [-1,1].forEach(s => {
    const win = new THREE.Mesh(new THREE.BoxGeometry(w*0.1, h*0.15, 0.2), winMat);
    win.position.set(s*w*0.3, h*0.6+1, d/2+0.05); g.add(win);
  });
  
  // Castle towers
  if (type === 'castle') {
    [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([sx,sz]) => {
      const tower = new THREE.Mesh(new THREE.CylinderGeometry(4,5,h*1.2,8), new THREE.MeshStandardMaterial({color:0x3d4f5f,roughness:0.85}));
      tower.position.set(sx*(w/2+2), h*0.6+1, sz*(d/2+2)); tower.castShadow = true; g.add(tower);
      const tRoof = new THREE.Mesh(new THREE.ConeGeometry(5,6,8), new THREE.MeshStandardMaterial({color:0x2c3e50}));
      tRoof.position.set(sx*(w/2+2), h*1.2+4, sz*(d/2+2)); tRoof.castShadow = true; g.add(tRoof);
    });
  }
  
  g.position.set(x, 0, z);
  scene.add(g);
  buildings.push(g);
}

function createTree(x, z) {
  const g = new THREE.Group();
  const s = 0.8 + Math.random() * 0.6;
  
  // Trunk
  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.4*s, 0.6*s, 5*s, 8), new THREE.MeshStandardMaterial({color:0x4a3520,roughness:0.95}));
  trunk.position.y = 2.5*s; trunk.castShadow = true; g.add(trunk);
  
  // Foliage - simplified
  const foliage = new THREE.Mesh(new THREE.SphereGeometry(3*s, 8, 6), new THREE.MeshStandardMaterial({color:0x2d5a27,roughness:0.85}));
  foliage.position.y = 6*s; foliage.castShadow = true; g.add(foliage);
  
  g.position.set(x, 0, z);
  scene.add(g);
}

function createRock(x, z) {
  const size = 0.8 + Math.random() * 1.5;
  const geo = new THREE.DodecahedronGeometry(size, 0);
  const rock = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:0x6a6a6a,roughness:0.95}));
  rock.position.set(x, size*0.4, z);
  rock.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
  rock.castShadow = true; rock.receiveShadow = true;
  scene.add(rock);
}

// MODERN WARFARE QUALITY CHARACTER - Detailed humanoid with proper proportions
function createMWPlayer() {
  const g = new THREE.Group();
  const skin = 0xd4a574, cloth = cfg.color, dark = 0x1a1a1a;
  
  // PELVIS/HIPS
  const pelvis = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.2, 0.25), new THREE.MeshStandardMaterial({color:dark,roughness:0.7}));
  pelvis.position.y = 0.95; pelvis.castShadow = true; g.add(pelvis);
  
  // TORSO - Detailed chest with muscle definition
  const torsoGeo = new THREE.BoxGeometry(0.55, 0.6, 0.3);
  const torso = new THREE.Mesh(torsoGeo, new THREE.MeshStandardMaterial({color:cloth,roughness:0.6,metalness:0.1}));
  torso.position.y = 1.35; torso.castShadow = true; g.add(torso);
  
  // CHEST PLATE / ARMOR DETAIL
  const chestPlate = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.35, 0.08), new THREE.MeshStandardMaterial({color:0x2a2a2a,roughness:0.4,metalness:0.3}));
  chestPlate.position.set(0, 1.4, 0.18); g.add(chestPlate);
  
  // SHOULDERS - Tactical shoulder pads
  [-1, 1].forEach(side => {
    const shoulder = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.12, 0.2), new THREE.MeshStandardMaterial({color:0x2a2a2a,roughness:0.5,metalness:0.2}));
    shoulder.position.set(side * 0.35, 1.55, 0); shoulder.castShadow = true; g.add(shoulder);
  });
  
  // NECK
  const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.12, 12), new THREE.MeshStandardMaterial({color:skin,roughness:0.7}));
  neck.position.y = 1.72; g.add(neck);
  
  // HEAD - Detailed with facial features
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.14, 24, 18), new THREE.MeshStandardMaterial({color:skin,roughness:0.6}));
  head.position.y = 1.9; head.castShadow = true; g.add(head);
  
  // FACE DETAILS
  const facePlate = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.12, 0.08), new THREE.MeshStandardMaterial({color:skin,roughness:0.6}));
  facePlate.position.set(0, 1.87, 0.1); g.add(facePlate);
  
  // EYES
  [-1, 1].forEach(side => {
    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 8), new THREE.MeshStandardMaterial({color:0x2a4a6a,roughness:0.3}));
    eye.position.set(side * 0.045, 1.9, 0.13); g.add(eye);
  });
  
  // HAIR/HELMET
  const hair = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 12, 0, Math.PI*2, 0, Math.PI*0.6), new THREE.MeshStandardMaterial({color:0x1a1008,roughness:0.9}));
  hair.position.y = 1.95; hair.castShadow = true; g.add(hair);
  
  // ARMS - Upper and Lower with proper joints
  [-1, 1].forEach(side => {
    // Upper arm
    const upperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.065, 0.35, 10), new THREE.MeshStandardMaterial({color:cloth,roughness:0.6}));
    upperArm.position.set(side * 0.38, 1.4, 0);
    upperArm.rotation.z = side * 0.15;
    upperArm.castShadow = true; g.add(upperArm);
    
    // Elbow joint
    const elbow = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), new THREE.MeshStandardMaterial({color:cloth,roughness:0.6}));
    elbow.position.set(side * 0.42, 1.2, 0); g.add(elbow);
    
    // Lower arm
    const lowerArm = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.055, 0.32, 10), new THREE.MeshStandardMaterial({color:skin,roughness:0.7}));
    lowerArm.position.set(side * 0.45, 1.0, 0);
    lowerArm.rotation.z = side * 0.1;
    lowerArm.castShadow = true; g.add(lowerArm);
    
    // Wrist
    const wrist = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), new THREE.MeshStandardMaterial({color:skin,roughness:0.7}));
    wrist.position.set(side * 0.47, 0.82, 0); g.add(wrist);
    
    // Hand
    const hand = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.04), new THREE.MeshStandardMaterial({color:skin,roughness:0.7}));
    hand.position.set(side * 0.48, 0.72, 0); hand.castShadow = true; g.add(hand);
    
    // Fingers (simplified)
    for (let f = 0; f < 4; f++) {
      const finger = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.012, 0.06, 6), new THREE.MeshStandardMaterial({color:skin,roughness:0.7}));
      finger.position.set(side * 0.48, 0.64, -0.015 + f * 0.012);
      finger.rotation.x = Math.PI/2; g.add(finger);
    }
  });
  
  // LEGS - Upper and Lower with proper joints
  [-1, 1].forEach(side => {
    // Upper leg/thigh
    const thigh = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.4, 10), new THREE.MeshStandardMaterial({color:dark,roughness:0.7}));
    thigh.position.set(side * 0.12, 0.7, 0);
    thigh.castShadow = true; g.add(thigh);
    
    // Knee joint
    const knee = new THREE.Mesh(new THREE.SphereGeometry(0.065, 8, 8), new THREE.MeshStandardMaterial({color:dark,roughness:0.7}));
    knee.position.set(side * 0.12, 0.48, 0); g.add(knee);
    
    // Knee pad
    const kneePad = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.06), new THREE.MeshStandardMaterial({color:0x2a2a2a,roughness:0.5,metalness:0.2}));
    kneePad.position.set(side * 0.12, 0.48, 0.05); g.add(kneePad);
    
    // Lower leg/shin
    const shin = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.07, 0.38, 10), new THREE.MeshStandardMaterial({color:dark,roughness:0.7}));
    shin.position.set(side * 0.12, 0.25, 0);
    shin.castShadow = true; g.add(shin);
    
    // Ankle
    const ankle = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), new THREE.MeshStandardMaterial({color:0x3d2817,roughness:0.8}));
    ankle.position.set(side * 0.12, 0.05, 0); g.add(ankle);
    
    // Boot
    const boot = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.18), new THREE.MeshStandardMaterial({color:0x2a1a0a,roughness:0.8}));
    boot.position.set(side * 0.12, 0.0, 0.03);
    boot.castShadow = true; g.add(boot);
  });
  
  // BELT with pouches
  const belt = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.08, 0.28), new THREE.MeshStandardMaterial({color:0x3a2a1a,roughness:0.7,metalness:0.1}));
  belt.position.y = 1.0; g.add(belt);
  
  // Belt buckle
  const buckle = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, 0.04), new THREE.MeshStandardMaterial({color:0xc0a000,roughness:0.3,metalness:0.7}));
  buckle.position.set(0, 1.0, 0.15); g.add(buckle);
  
  // Pouches
  [-1, 1].forEach(side => {
    const pouch = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.06), new THREE.MeshStandardMaterial({color:0x3a2a1a,roughness:0.8}));
    pouch.position.set(side * 0.2, 0.95, 0.12); g.add(pouch);
  });
  
  player = g;
  player.position.set(0, 3, 0);
  scene.add(player);
}

// MODERN WARFARE QUALITY ENEMY
function createMWEnemy(x, z, type) {
  const g = new THREE.Group();
  const skin = type.hostile ? 0x8a6a5a : 0xd4a574;
  
  // Body
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.55, 0.28), new THREE.MeshStandardMaterial({color:type.color,roughness:0.6}));
  torso.position.y = 1.3; torso.castShadow = true; g.add(torso);
  
  // Armor plate
  const armor = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.3, 0.06), new THREE.MeshStandardMaterial({color:0x2a2a2a,roughness:0.4,metalness:0.3}));
  armor.position.set(0, 1.35, 0.16); g.add(armor);
  
  // Head
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.13, 16, 12), new THREE.MeshStandardMaterial({color:skin,roughness:0.6}));
  head.position.y = 1.75; head.castShadow = true; g.add(head);
  
  // Hood/helmet for hostile
  if (type.hostile) {
    const hood = new THREE.Mesh(new THREE.SphereGeometry(0.14, 12, 10, 0, Math.PI*2, 0, Math.PI*0.7), new THREE.MeshStandardMaterial({color:0x2a1a1a,roughness:0.9}));
    hood.position.y = 1.78; g.add(hood);
  }
  
  // Arms
  [-1, 1].forEach(side => {
    const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.055, 0.5, 8), new THREE.MeshStandardMaterial({color:type.color,roughness:0.6}));
    arm.position.set(side * 0.32, 1.15, 0);
    arm.rotation.z = side * 0.15;
    arm.castShadow = true; g.add(arm);
    
    const hand = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), new THREE.MeshStandardMaterial({color:skin,roughness:0.7}));
    hand.position.set(side * 0.38, 0.85, 0); g.add(hand);
  });
  
  // Legs
  [-1, 1].forEach(side => {
    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.07, 0.7, 8), new THREE.MeshStandardMaterial({color:0x1a1a1a,roughness:0.7}));
    leg.position.set(side * 0.1, 0.55, 0);
    leg.castShadow = true; g.add(leg);
    
    const boot = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.08, 0.14), new THREE.MeshStandardMaterial({color:0x2a1a0a,roughness:0.8}));
    boot.position.set(side * 0.1, 0.15, 0.02); g.add(boot);
  });
  
  // Health bar
  const hpBg = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.12), new THREE.MeshBasicMaterial({color:0x222222,side:THREE.DoubleSide}));
  hpBg.position.y = 2.1; g.add(hpBg);
  const hpBar = new THREE.Mesh(new THREE.PlaneGeometry(1.1, 0.08), new THREE.MeshBasicMaterial({color:type.hostile?0xff3333:0x3388ff,side:THREE.DoubleSide}));
  hpBar.position.set(0, 2.1, 0.01); g.add(hpBar);
  
  g.position.set(x, 0, z);
  g.userData = { type:'enemy', enemyType:type, hp:type.hp, maxHp:type.hp, state:'patrol', vx:(Math.random()-0.5)*2, vz:(Math.random()-0.5)*2, hpBar };
  scene.add(g);
  enemies.push(g);
}

// MODERN WARFARE QUALITY NPC
function createMWNPC(x, z, name, color, role) {
  const g = new THREE.Group();
  
  // Body
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.48, 0.55, 0.26), new THREE.MeshStandardMaterial({color,roughness:0.5,metalness:0.1}));
  torso.position.y = 1.3; torso.castShadow = true; g.add(torso);
  
  // Head
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.13, 20, 14), new THREE.MeshStandardMaterial({color:0xd4a574,roughness:0.6}));
  head.position.y = 1.75; head.castShadow = true; g.add(head);
  
  // Hair
  const hair = new THREE.Mesh(new THREE.SphereGeometry(0.14, 12, 10, 0, Math.PI*2, 0, Math.PI*0.5), new THREE.MeshStandardMaterial({color:0x3a2a1a,roughness:0.9}));
  hair.position.y = 1.8; g.add(hair);
  
  // Arms
  [-1, 1].forEach(side => {
    const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.5, 8), new THREE.MeshStandardMaterial({color,roughness:0.5}));
    arm.position.set(side * 0.3, 1.15, 0);
    arm.rotation.z = side * 0.12;
    arm.castShadow = true; g.add(arm);
  });
  
  // Legs
  [-1, 1].forEach(side => {
    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.065, 0.65, 8), new THREE.MeshStandardMaterial({color:0x2a2a3a,roughness:0.7}));
    leg.position.set(side * 0.1, 0.55, 0);
    leg.castShadow = true; g.add(leg);
  });
  
  // Quest indicator
  const ind = new THREE.Mesh(new THREE.OctahedronGeometry(0.18, 0), new THREE.MeshStandardMaterial({color:0xffff00,emissive:0xffaa00,emissiveIntensity:1,roughness:0.2}));
  ind.position.y = 2.2; g.add(ind);
  g.userData.indicator = ind;
  
  // Light
  const light = new THREE.PointLight(0xffaa44, 0.6, 6);
  light.position.y = 2; g.add(light);
  
  g.position.set(x, 0, z);
  g.userData.type = 'npc';
  g.userData.name = name;
  g.userData.role = role;
  scene.add(g);
  npcs.push(g);
}

function createItem(x, z) {
  const types = [
    { name: 'Apple', color: 0xff2222, effect: 'hunger', value: 15 },
    { name: 'Bread', color: 0xdaa520, effect: 'hunger', value: 25 },
    { name: 'Health Potion', color: 0xff44ff, effect: 'health', value: 40 },
    { name: 'Gold Coin', color: 0xffd700, effect: 'gold', value: 10 }
  ];
  const type = types[Math.floor(Math.random() * types.length)];
  
  const item = new THREE.Mesh(new THREE.OctahedronGeometry(0.35, 0), new THREE.MeshStandardMaterial({color:type.color,emissive:type.color,emissiveIntensity:0.4,roughness:0.2,metalness:0.6}));
  item.position.set(x, 0.7, z);
  item.castShadow = true;
  item.userData = { type: 'item', itemType: type, collected: false };
  
  const glow = new THREE.PointLight(type.color, 0.4, 3);
  item.add(glow);
  
  scene.add(item);
  items.push(item);
}

function setupPostProcessing() {
  composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.25, 0.3, 0.9));
  composer.addPass(new SMAAPass(window.innerWidth, window.innerHeight));
}

function setupControls(canvas) {
  document.addEventListener('keydown', e => { 
    keys[e.code] = true;
    if (e.code === 'KeyE') handleInteract();
    if (e.code === 'KeyQ') handleAttack();
    if (e.code === 'Space' && isGrounded) { playerVelocityY = JUMP_FORCE; isGrounded = false; }
  });
  document.addEventListener('keyup', e => { keys[e.code] = false; });
  
  document.addEventListener('mousemove', e => {
    if (isLocked) {
      playerYaw -= e.movementX * 0.002;
      playerPitch -= e.movementY * 0.0015;
      playerPitch = Math.max(-1, Math.min(1, playerPitch));
    }
  });
  
  canvas.addEventListener('click', () => canvas.requestPointerLock());
  document.addEventListener('pointerlockchange', () => { isLocked = document.pointerLockElement === canvas; });
  
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  });
}

function handleInteract() {
  for (const npc of npcs) {
    if (player.position.distanceTo(npc.position) < 4) {
      const dialogs = { trade: '"Welcome! I have the finest wares."', craft: '"Need steel forged? I am the best!"', quest: '"The bandits grow bolder. Will you help?"', heal: '"Let me tend to your wounds."' };
      log(npc.userData.name + ': ' + dialogs[npc.userData.role], 'ai');
      if (npc.userData.role === 'heal' && hp < maxHp) { hp = Math.min(maxHp, hp + 50); log('Healed! +50 HP', 'system'); }
      return;
    }
  }
  for (const item of items) {
    if (item.userData.collected) continue;
    if (player.position.distanceTo(item.position) < 3) {
      item.userData.collected = true; item.visible = false;
      const t = item.userData.itemType;
      log('Collected: ' + t.name, 'quest');
      if (t.effect === 'hunger') hunger = Math.min(100, hunger + t.value);
      if (t.effect === 'health') hp = Math.min(maxHp, hp + t.value);
      return;
    }
  }
}

function handleAttack() {
  for (const enemy of enemies) {
    if (enemy.userData.hp <= 0) continue;
    if (player.position.distanceTo(enemy.position) < 4) {
      const dmg = cfg.dmg + Math.floor(Math.random() * 8);
      enemy.userData.hp -= dmg;
      log('Hit ' + enemy.userData.enemyType.name + ' for ' + dmg + ' damage!', 'combat');
      enemy.userData.hpBar.scale.x = Math.max(0, enemy.userData.hp / enemy.userData.maxHp);
      enemy.userData.state = 'chase';
      if (enemy.userData.hp <= 0) { log(enemy.userData.enemyType.name + ' defeated!', 'combat'); heat.bandits = Math.min(100, heat.bandits + 10); }
      return;
    }
  }
}

function getGroundHeight(x, z) {
  raycaster.set(new THREE.Vector3(x, 50, z), new THREE.Vector3(0, -1, 0));
  const hits = raycaster.intersectObject(groundMesh);
  return hits.length > 0 ? hits[0].point.y : 0;
}

function gameLoop() {
  requestAnimationFrame(gameLoop);
  const dt = Math.min(clock.getDelta(), 0.05);
  
  // Movement
  let mx = 0, mz = 0;
  if (keys.KeyW || keys.ArrowUp) mz = -1;
  if (keys.KeyS || keys.ArrowDown) mz = 1;
  if (keys.KeyA || keys.ArrowLeft) mx = -1;
  if (keys.KeyD || keys.ArrowRight) mx = 1;
  
  const running = keys.ShiftLeft && stamina > 0;
  const speed = (running ? cfg.spd * 2 : cfg.spd) * dt;
  
  if (mx || mz) {
    const angle = Math.atan2(mx, mz) + playerYaw;
    player.position.x += Math.sin(angle) * speed;
    player.position.z += Math.cos(angle) * speed;
    if (running) stamina = Math.max(0, stamina - 20 * dt);
  }
  
  if (!running) stamina = Math.min(100, stamina + 15 * dt);
  hunger = Math.max(0, hunger - 0.1 * dt);
  if (hunger <= 0) hp -= dt * 3;
  
  player.position.x = Math.max(-280, Math.min(280, player.position.x));
  player.position.z = Math.max(-280, Math.min(280, player.position.z));
  player.rotation.y = playerYaw;
  
  // Gravity
  const groundY = getGroundHeight(player.position.x, player.position.z);
  playerVelocityY -= GRAVITY * dt;
  player.position.y += playerVelocityY * dt;
  if (player.position.y <= groundY) { player.position.y = groundY; playerVelocityY = 0; isGrounded = true; }
  else isGrounded = false;
  
  // Camera
  camera.position.x = player.position.x - Math.sin(playerYaw) * 5;
  camera.position.y = player.position.y + 2.5 - playerPitch * 2;
  camera.position.z = player.position.z - Math.cos(playerYaw) * 5;
  camera.lookAt(player.position.x, player.position.y + 1.6, player.position.z);
  
  // Sun follows player
  sun.position.set(player.position.x + 50, 100, player.position.z + 50);
  sun.target.position.copy(player.position);
  
  // Enemies
  updateEnemies(dt);
  
  // NPCs
  npcs.forEach(npc => {
    npc.position.y = getGroundHeight(npc.position.x, npc.position.z);
    if (npc.userData.indicator) {
      npc.userData.indicator.rotation.y += dt * 2;
      npc.userData.indicator.position.y = 2.2 + Math.sin(Date.now() * 0.004) * 0.15;
    }
  });
  
  // Items
  items.forEach(item => {
    if (!item.userData.collected) {
      item.position.y = getGroundHeight(item.position.x, item.position.z) + 0.7 + Math.sin(Date.now() * 0.003) * 0.15;
      item.rotation.y += dt * 2;
    }
  });
  
  // Time
  gameTime += dt * 0.02;
  if (gameTime >= 24) { gameTime = 0; day++; log('Day ' + day + ' dawns...', 'system'); }
  
  heat.kingdom = Math.max(0, heat.kingdom - 0.1 * dt);
  heat.bandits = Math.max(0, heat.bandits - 0.1 * dt);
  
  updateHUD();
  updateMinimap();
  
  if (hp <= 0) { log('Respawning...', 'combat'); hp = maxHp; stamina = 100; player.position.set(0, getGroundHeight(0,0)+1, 0); playerVelocityY = 0; }
  
  composer.render();
}

function updateEnemies(dt) {
  enemies.forEach(enemy => {
    if (enemy.userData.hp <= 0) { enemy.visible = false; return; }
    const data = enemy.userData, type = data.enemyType;
    const dist = player.position.distanceTo(enemy.position);
    
    // Face HP bars to camera
    const hpBg = enemy.children.find(c => c.geometry?.parameters?.width === 1.2);
    if (hpBg) hpBg.lookAt(camera.position);
    if (data.hpBar) data.hpBar.lookAt(camera.position);
    
    if (type.hostile) {
      if (dist < 35 && dist > 2) {
        const dir = player.position.clone().sub(enemy.position).normalize();
        enemy.position.x += dir.x * type.spd * dt;
        enemy.position.z += dir.z * type.spd * dt;
        enemy.lookAt(player.position.x, enemy.position.y, player.position.z);
      } else if (dist <= 2 && Math.random() < dt * 1.5) {
        const dmg = Math.max(1, type.dmg - Math.floor(cfg.armor * type.dmg));
        hp -= dmg;
        log(type.name + ' hits you for ' + dmg + '!', 'combat');
      } else if (dist >= 35) {
        enemy.position.x += data.vx * dt;
        enemy.position.z += data.vz * dt;
        if (Math.abs(enemy.position.x) > 150) data.vx *= -1;
        if (Math.abs(enemy.position.z) > 150) data.vz *= -1;
      }
    } else {
      enemy.position.x += data.vx * 0.3 * dt;
      enemy.position.z += data.vz * 0.3 * dt;
      if (Math.abs(enemy.position.x) > 100) data.vx *= -1;
      if (Math.abs(enemy.position.z) > 100) data.vz *= -1;
    }
    enemy.position.y = getGroundHeight(enemy.position.x, enemy.position.z);
  });
}

function updateHUD() {
  document.getElementById('hp').style.width = (hp / maxHp * 100) + '%';
  document.getElementById('st').style.width = stamina + '%';
  document.getElementById('hu').style.width = hunger + '%';
  document.getElementById('hp-text').textContent = Math.floor(hp) + '/' + maxHp;
  document.getElementById('st-text').textContent = Math.floor(stamina) + '%';
  document.getElementById('hu-text').textContent = Math.floor(hunger) + '%';
  
  const h = Math.floor(gameTime), m = Math.floor((gameTime % 1) * 60);
  document.getElementById('day').textContent = 'Day ' + day + ' | ' + String(h).padStart(2,'0') + ':' + String(m).padStart(2,'0');
  
  let weather = '‚òÄÔ∏è Clear';
  if (gameTime < 6 || gameTime > 20) weather = 'üåô Night';
  else if (gameTime > 17) weather = 'üåÖ Sunset';
  else if (gameTime < 8) weather = 'üåÑ Dawn';
  document.getElementById('weather').textContent = weather + ' | 22¬∞C';
  
  const hk = document.getElementById('h-kingdom'), hb = document.getElementById('h-bandits');
  hk.textContent = heat.kingdom < 25 ? 'CALM' : heat.kingdom < 50 ? 'ALERT' : 'HUNTING';
  hk.className = 'heat-tag ' + (heat.kingdom < 25 ? 'calm' : heat.kingdom < 50 ? 'alert' : 'hunting');
  hb.textContent = heat.bandits < 25 ? 'CALM' : heat.bandits < 50 ? 'ALERT' : 'HUNTING';
  hb.className = 'heat-tag ' + (heat.bandits < 25 ? 'calm' : heat.bandits < 50 ? 'alert' : 'hunting');
}

function updateMinimap() {
  const canvas = document.getElementById('minimap');
  const ctx = canvas.getContext('2d');
  const size = 180, scale = 0.25, cx = size/2, cy = size/2;
  
  ctx.save();
  ctx.beginPath(); ctx.arc(cx, cy, size/2-3, 0, Math.PI*2); ctx.clip();
  ctx.fillStyle = '#0a1a0a'; ctx.fillRect(0, 0, size, size);
  
  ctx.strokeStyle = '#1a2a1a'; ctx.lineWidth = 1;
  for (let i = -200; i <= 200; i += 50) {
    const gx = cx + i * scale;
    ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, size); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, gx); ctx.lineTo(size, gx); ctx.stroke();
  }
  
  const px = player.position.x, pz = player.position.z;
  
  ctx.fillStyle = '#4a4a3a';
  buildings.forEach(b => {
    const x = cx + (b.position.x - px) * scale, z = cy + (b.position.z - pz) * scale;
    if (Math.sqrt((x-cx)**2 + (z-cy)**2) < size/2-5) ctx.fillRect(x-4, z-4, 8, 8);
  });
  
  enemies.forEach(e => {
    if (e.userData.hp <= 0) return;
    const x = cx + (e.position.x - px) * scale, z = cy + (e.position.z - pz) * scale;
    if (Math.sqrt((x-cx)**2 + (z-cy)**2) < size/2-5) {
      ctx.fillStyle = e.userData.enemyType.hostile ? '#ff4444' : '#4488ff';
      ctx.beginPath(); ctx.arc(x, z, 3, 0, Math.PI*2); ctx.fill();
    }
  });
  
  ctx.fillStyle = '#44ff44';
  npcs.forEach(n => {
    const x = cx + (n.position.x - px) * scale, z = cy + (n.position.z - pz) * scale;
    if (Math.sqrt((x-cx)**2 + (z-cy)**2) < size/2-5) { ctx.beginPath(); ctx.arc(x, z, 4, 0, Math.PI*2); ctx.fill(); }
  });
  
  ctx.fillStyle = '#ffff44';
  items.forEach(i => {
    if (i.userData.collected) return;
    const x = cx + (i.position.x - px) * scale, z = cy + (i.position.z - pz) * scale;
    if (Math.sqrt((x-cx)**2 + (z-cy)**2) < size/2-5) ctx.fillRect(x-2, z-2, 4, 4);
  });
  
  ctx.restore();
  
  ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx - Math.sin(playerYaw)*18, cy - Math.cos(playerYaw)*18); ctx.stroke();
  ctx.beginPath(); ctx.arc(cx, cy, size/2-2, 0, Math.PI*2); ctx.stroke();
}

function log(msg, type = 'system') {
  const el = document.getElementById('log-entries');
  const div = document.createElement('div');
  div.className = 'log-entry log-' + type;
  const h = Math.floor(gameTime), m = Math.floor((gameTime % 1) * 60);
  div.textContent = '[' + String(h).padStart(2,'0') + ':' + String(m).padStart(2,'0') + '] ' + msg;
  el.insertBefore(div, el.firstChild);
  while (el.children.length > 20) el.removeChild(el.lastChild);
}

console.log('‚öîÔ∏è Surviving The World‚Ñ¢ - Modern Warfare Quality Engine');
console.log('üéÆ Optimized: 60 FPS | Detailed Characters | PBR Materials');
</script>
</body>
</html>